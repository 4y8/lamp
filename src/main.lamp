undefined = I;

-- Types
-- Booleans
True  = \x _ -> x;
False = \_ y -> y;

(||) f g x y = f x (g x y);
(&&) f g x y = f (g x y) y;

-- Pairs
(,) x y     = \f -> f x y;
curry f l r = f (l, r);
uncurry f x = x f;
fst x = x const;
snd x = x (\_ s -> s);

-- Maybe
Nothing = K;
Just x  = \_ g -> g x;
get e = e undefined id;

-- Lists
Nil     = K;
(:) h t = \_ g -> g h t;
(++) l l' =
  l
    l'
    (\h t -> h : (t ++ l'));

ifNil l t f = l t (\_ _ -> f);
head l = l undefined (\h _ -> h);
tail l = l undefined (\_ t -> t);
cmp_list l l' =
  l
    (l'
      True
      (\_ _ -> False))
    (\h t ->
      l'
        False
	(\h' t' ->
	  (h == h')
	    (cmp_list t t')
	    False));

-- Combinators
id x = x;
const x _ = x;
fix x = x (fix x);
flip f x y = f y x;

(&) x f = f x;
($) f x = f x;
(.) f g x = f (g x);

-- Parser combinator library
pure x inp = Just (x, inp);
bind f m = m Nothing (\x -> x f);

-- case x inp of
--   Nothing      -> Nothing
--   Just (a, l)  ->
--     case y l of
--       Nothing -> Nothing
--       Just (b, l') -> Just (a b, l')
(<*>) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q t)) (p inp);

-- case x inp of
--   Nothing -> y inp
--   Just n  -> Just n
(<|>) p q = \inp -> (p inp) (q inp) Just;

(<$>) f p = pure f <*> p;

(<$) f p = const <$> pure f <*> p;
(<*) p q = const <$> p      <*> q;
(*>) p q = id    <$  p      <*> q;

opt def x = x <|> pure def;
many p = opt Nil ((:) <$> p <*> many p);
many1 p = (:) <$> p <*> many p;
appall x l = l x (\h t -> appall (h x) t);
chainl1 op p = appall <$> p <*> many (flip <$> op <*> p);

range l r = sat (\x -> (l <= x) && (x <= r));
lower = range 'a' 'z';
upper = range 'A' 'Z';
letter = lower <|> upper;
ide = letter <|> char ''' <|> char '_';

-- Ast
-- data Expr = Com [Char] | Var [Char] | App Expr Expr | Lam [Char] Expr
Com c   = \a _ _ _ -> a c;
Var v   = \_ b _ _ -> b v;
App l r = \_ _ c _ -> c l r;
Lam v b = \_ _ _ d -> d v b;

(@) = App;

-- Parser

-- Parses a character satisfying the predicate f.
-- case inp of
--   [] -> Nothing
--   h : tl -> if f h then (pure h t) else Nothing
sat f inp = inp Nothing (\h t -> f h (pure h t) Nothing);

-- Matches the character c.
char c = sat ((==) c);
-- Matches any character.
any = sat (\_ -> const);

space = char ' ';
spaces = many space;

char_v = sat (\c -> flip ((c == ';') || (c == ')')));
pre = Com <$> (((:) <$> (char '#' <|> char '@')) <*> ((\c -> c : Nil) <$> any));

parent r = char '(' *> spaces *> r <* spaces <* char ')';

lambda r =
  Lam
  <$  char '\'
  <*  spaces
  <*> many1 ide
  <*  spaces
  <*  char '-'
  <*  char '>'
  <*  spaces
  <*> r;

var    = Var <$> many1 ide;
atom r = parent r <|> pre <|> lambda r <|> var;
app    = chainl1 (spaces *> pure App <* spaces) (atom app);

-- case e of
--   Com c -> c
--   Var v -> [v]
--   App l r -> (show l) ++ (show r)
--   Lam v b -> '\' : v : '.' ++ (show b)
show e =
  e
    id
    id
    (\l r -> '`' : show l ++ show r)
    (\v b -> '\': (v ++ ('.' : show b)));

-- Bracket abstraction

comb v = Var (v : Nil);

-- case e of
--   Com c -> App (Var 'K') e
--   Var v' -> if v' == v then Var 'I' else App (Var 'K') e
--   App l r -> App (App (Var 'S') (abs v l)) (abs v r)
abs v e =
  e
    (\_ -> comb 'K' @ e)
    (\v' -> (cmp_list v' v)
            (comb 'I')
            (comb 'K' @ e))
    (\l r -> comb 'S' @ abs v l @ abs v r)
    undefined;

-- case e of
--   Com _ -> e
--   Var _ -> e
--   App l r -> App (babs l) (babs r)
--   Lam v b -> abs v (babs b)
babs e =
  e
    Com
    Var
    (\l r -> babs l @ babs r)
    (\v b -> abs v (babs b));

main = (show . babs . fst . get . app);