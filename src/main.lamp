undefined = I;

-- Combinators
id = I;
const = K;
flip = C;
(.) = B;

-- Types
-- Booleans
True  = \x _ -> x;
False = \_ y -> y;

(||) f g x y = f x (g x y);
(&&) f g x y = f (g x y) y;

(==) = E;
(<=) = L;

-- Pairs
(,) x y     = \f -> f x y;
fst x = x const;
snd x = x (\_ s -> s);

-- Maybe
Nothing = K;
Just x  = \_ g -> g x;
get e = e undefined id;

-- Lists
Nil = K;

(++) l l' =
  l
    l'
    (\h t -> h : (t ++ l'));

reverse l =
  l
    Nil
    (\h t -> (reverse t) ++ (h : Nil));

map f l = l Nil (\h t -> f h : map f t);

foldr f acc l = l acc (\h t -> f h (foldr f acc t));

head l = l undefined (\h _ -> h);
tail l = l undefined (\_ t -> t);
cmp_list l l' =
  l
    (l'
      True
      (\_ _ -> False))
    (\h t ->
      l'
        False
	(\h' t' ->
	  (h == h')
	    (cmp_list t t')
	    False));

last l = l undefined (\h t -> t h (\_ _ -> last t));

-- Parser combinator library
pure x inp = Just (x, inp);
fail = const Nothing;
bind f m = m Nothing (\x -> x f);

-- case x inp of
--   Nothing      -> Nothing
--   Just (a, l)  ->
--     case y l of
--       Nothing -> Nothing
--       Just (b, l') -> Just (a b, l')
(<*>) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q t)) (p inp);
(<*>|) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q I t)) (p inp);

-- case x inp of
--   Nothing -> y inp
--   Just n  -> Just n
(<|>) p q = \inp -> (p inp) (q inp) Just;

(<$>) f p = pure f <*> p;

(<$) f p = const <$> pure f <*> p;
(<*) p q = const <$> p      <*> q;
(*>) p q = id    <$  p      <*> q;

opt def x = x <|> pure def;
many p = opt Nil ((:) <$> p <*>| (\_ -> many p));
many1 p = (:) <$> p <*> many p;
appall x l = l x (\h t -> appall (h x) t);
chainl1 op p = appall <$> p <*> many (flip <$> op <*> p);
choice = foldr (<|>) fail;

sepBy1 sep p  = (:) <$> p <*> many (sep *> p);
sepBy sep p = opt Nil (sepBy1 sep p);

range l r = sat (\x -> (l <= x) && (x <= r));
lower = range 'a' 'z';
upper = range 'A' 'Z';
letter = lower <|> upper;
ide = letter <|> char ''' <|> char '_';
digit = range '0' '9';

-- Ast
-- data Expr = Com [Char] | Var [Char] | App Expr Expr | Lam [Char] Expr
Com c   = \a _ _ _ -> a c;
Var v   = \_ b _ _ -> b v;
App l r = \_ _ c _ -> c l r;
Lam v b = \_ _ _ d -> d v b;

comb v = Var (v : Nil);

(@) = App;

-- Parser

-- Parses a character satisfying the predicate f.
-- case inp of
--   [] -> Nothing
--   h : tl -> if f h then (pure h t) else Nothing
sat f inp = inp Nothing (\h t -> f h (pure h t) Nothing);

-- Matches the character c.
char c = sat ((==) c);
-- Matches any character.
any = sat (\_ -> const);

space = char ' ';
newline = char '
';
tab = char '	';

nul = space
  <|> tab
  <|> newline
  <|> (char '-'
   <*  char '-'
    *> many (sat (\x -> (x == '
') False True)));

blank p = many nul
       *> p
      <*  many nul;

operators = ":=|+-,.&<*>$@";

op = choice (map char operators);
opp = many op;

parentP = char '(' *> blank expr <* char ')';

name = (:) <$> ide <*> many (ide <|> digit);

lambdaP = (flip wrap_lam . reverse)
      <$  char '\'
      <*> many (blank name)
      <*  char '-'
      <*  char '>'
      <*  many nul
      <*> expr;

chr c = Com ('#' : (c : Nil));

charP = chr
    <$  char '''
    <*> any
    <*  char ''';

str l = l
          (Var "K")
	  (\h t -> comb ':' @ chr h @ str t);

dquote = '"'; --"

stringP = str
      <$  char dquote
      <*> many (sat (\x -> (x == dquote) False True))
      <*  char dquote;

lst l = l
         (Var "K")
         (\h t -> Var ":" @ h @ lst t);

listP = lst
    <$  blank (char '[')
    <*> sepBy (blank (char ';')) expr
    <*  blank (char ']');

varP  = Var <$> (name <|> (char '(' *> blank opp <* char ')'));
atomP = parentP <|> charP <|> lambdaP <|> varP <|> stringP <|> listP;
appP  = chainl1 (blank (pure App)) atomP;
expr  = chainl1 ((\x y z -> Var x @ y @ z) <$> blank opp) appP;

wrap_lam e l =
  l
    e
    (\h t ->
      wrap_lam (Lam h e) t);

equal = (flip wrap_lam . reverse)
    <$> many (blank name)
    <*  blank (char '=')
    <*> expr;

top_level = (,)
        <$> (name <|> (char '(' *> blank opp <* char ')'))
        <*> blank equal
        <*  char ';';

-- case e of
--   Com c -> c
--   Var v -> v
--   App l r -> (show l) ++ (show r)
--   Lam v b -> '\' : v ++ ('.' : (show b))
show e =
  e
    id
    id
    (\l r -> '`' : show l ++ show r)
    (\v b -> '\': (v ++ ('.' : show b)));

-- Bracket abstraction
-- case e of
--   App l r ->
--     case l of
--       App l' r' ->
--         case l' of
--           Var v ->
--             if v == "S"
--             then
--             case r' of
--               App l'' r'' ->
--                 case l'' of
--                   Var v ->
--                     if v == "K"
--                     then
--                     case r of
--                       Var v -> if v == "I" then r'' else Var "B" @ r'' @ r
--                       App l''' r''' ->
--                         case l''' of
--                           Var v -> if v == "K" then Var "K" @ (r'' @ r''')
--                           _ -> Var "B" @ r'' @ r
--                       _ -> Var "B" @ r'' @ r
--                     else e
--                   _ -> e
--               _ -> e
--             else e
--           _ -> e
--       _ -> e
--   _ -> e

app e f def = e (const def) (const def) f (\_ _ -> def);

var e v f def =
  e
    (const def)
    (\v' -> (cmp_list (v : Nil) v') f def)
    (\_ _ -> def)
    (\_ _ -> def);

bopt p q = Var "B" @ p @ q;
kopt s p q l r = var
                   l
                   'K'
                   (Var "K" @ (q @ r))
                   (bopt q s);

copt e s p =
  app
    s
    (\l q ->
      var
        l
        'K'
        (Var "C" @ p @ q)
        e)
    e;

svopt e s p l q = var
                    l
                    'K'
                    (s
                       (const (bopt q s))
                       (\v -> (cmp_list "I" v) q (bopt q s))
                       (kopt s p q)
                       (\_ _ -> bopt q s))
                    e;

optimize e =
  app
    e
    (\l s ->
      app
        l
        (\l' p ->
          var
            l'
            'S'
            (app
              p
              (svopt e s p)
              (copt e s p))
            e)
        e)
    e;

abs v e =
  e
    (\_ -> Var "K" @ e)
    (\v' -> (cmp_list v' v)
            (Var "I")
            (Var "K" @ e))
    (\l r -> optimize (comb 'S' @ abs v l @ abs v r))
    undefined;

inc n = n + '!' - ' ';

babs e =
  e
    Com
    Var
    (\l r -> (babs l) @ (babs r))
    (\v b -> abs v (babs b));

find_list a l =
  l
    undefined
    (\h t ->
      (cmp_list (fst h) a)
        (' ' - ' ')
        (inc (find_list a t)));

combinators = "SICKBEL+-:";

is_comb v l = l False (\h t -> (cmp_list v (h : Nil)) True (is_comb v t));

subst e l = e
               Com
               (\v ->
                 (is_comb v combinators)
                   e
                   (Com ('@' : ((' ' + find_list v l) : Nil))))
               (\p q -> subst p l @ subst q l)
               (\v b -> Lam v (subst b l));

smap f l = l Nil (\h t -> (fst h, f (snd h)) : smap f t);

main = (foldr (\l l' -> l ++ (';' : l')) Nil .
        map (show . snd) .
        (\l -> smap (flip subst l . babs) l) .
        fst .
        get .
        many (blank top_level));
