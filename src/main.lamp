undefined = I;

-- Types
(,) x y     = \f -> f x y;
curry f l r = f (l, r);
uncurry f x = x f;
fst x = x const;
snd x = x (\_ s -> s);

Nothing = K;
Just x  = \_ g -> g x;
get e = e undefined id;

(.) f g x = f (g x);

Nil     = K;
(:) h t = \_ g -> g h t;

-- Combinators
id x = x;
const x _ = x;
fix x = x (fix x);
flip f x y = f y x;

(&) x f = f x;
($) f x = f x;
(||) f g x y = f x (g x y);

-- Lists
(++) l l' = l l' (\h t -> h : (t ++ l'));
ifNil l t f = l t (\_ _ -> f);
head l = l undefined (\h _ -> h);
tail l = l undefined (\_ t -> t);

-- Parser for combinators
closes h = (hd == ')') || (hd == ';');
pre h = (hd == '#') || (hd == '@');
add r acc p = r (ifNil acc p ('`' : (acc ++ p)));

sub r acc t = uncurry (add r acc) (r Nil t);

atom r acc h t = ((\x y -> add r acc h:x y) (pre h (((head t) : Nil), (tail t)) (Nil, t)));

term acc s =
    s undefined (\h t -> (closes h) (acc, t) ((h == '(') (sub term acc t) (atom term acc h t)));

-- Parser combinator library
pure x inp = Just (x, inp);
bind f m = m Nothing (\x -> x f);

-- case x inp of
--   Nothing      -> Nothing
--   Just (a, l)  ->
--     case y l of
--       Nothing -> Nothing
--       Just (b, l') -> Just (a b, l')
(<*>) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q t)) (p inp);

-- case x inp of
--   Nothing -> y inp
--   Just n  -> Just n
(<|>) p q = \inp -> (p inp) (q inp) Just;

(<$>) f p = pure f <*> p;

(<$) f p = const <$> pure f <*> p;
(<*) p q = const <$> p      <*> q;
(*>) p q = id    <$  p      <*> q;

opt def x = x <|> pure def;
many p = opt Nil ((:) <$> p <*> many p);
appall x l = l x (\h t -> appall (h x) t);
chainl1 op p = appall <$> p <*> many (flip <$> op <*> p);

-- Ast
-- data Expr = Com [Char] | Var Char | App Expr Expr | Lam Char Expr
Com c   = \a _ _ _ -> a c;
Var v   = \_ b _ _ -> b v;
App l r = \_ _ c _ -> c l r;
Lam v b = \_ _ _ d -> d v b;

(@) = App;

-- Parser

-- Parses a character satisfying the predicate f.
-- case inp of
--   [] -> Nothing
--   h : tl -> if f h then (pure h t) else Nothing
sat f inp = inp Nothing (\h t -> f h (pure h t) Nothing);

-- Matches the character c.
char c = sat ((==) c);
-- Matches any character.
any = sat (\_ -> const);

char_v = sat (\c -> flip ((c == ';') || (c == ')')));
pre = Com <$> (((:) <$> (char '#' <|> char '@')) <*> ((\c -> c : Nil) <$> any));

parent r = char '(' *> r <* char ')';
lambda r = Lam <$> (char '\' *> char_v) <*> (char '.' *> r);
var = Var <$> char_v;
app r = App <$> r <*> r;
atom r = parent r <|> pre <|> lambda r <|> var;
app = chainl1 (pure App) (atom app);

-- case e of
--   Com c -> c
--   Var v -> [v]
--   App l r -> (show l) ++ (show r)
--   Lam v b -> '\' : v : '.' ++ (show b)
show e =
  e
    id
    (\x -> x : Nil)
    (\l r -> '`' : show l ++ show r)
    (\v b -> '\': (v : ('.' : show b)));


-- Bracket abstraction

-- case e of
--   Com c -> App (Var 'K') e
--   Var v' -> if v' == v then Var 'I' else App (Var 'K') e
--   App l r -> App (App (Var 'S') (abs v l)) (abs v r)
abs v e =
  e
    (\_ -> Var 'K' @ e)
    (\v' -> (v' == v)
            (Var 'I')
            (Var 'K' @ e))
    (\l r -> Var 'S' @ abs v l @ abs v r)
    undefined;

-- case e of
--   Com _ -> e
--   Var _ -> e
--   App l r -> App (babs l) (babs r)
--   Lam v b -> abs v (babs b)
babs e =
  e
    Com
    Var
    (\l r -> babs l @ babs r)
    (\v b -> abs v (babs b));

main = (show . babs . fst . get . app);