undefined = I;
id = I;
const = K;
flip = C;
(.) = B;

True  = \x _ -> x;
False = \_ y -> y;

(||) f g x y = f x (g x y);
(&&) f g x y = f (g x y) y;

(==) = E;
(<=) = L;

(,) x y     = \f -> f x y;
fst x = x const;
snd x = x (\_ s -> s);

Nothing = K;
Just x  = \_ g -> g x;
get e = e undefined id;

Nil = K;

(++) l l' =
  l
    l'
    (\h t -> h : (t ++ l'));

reverse l =
  l
    Nil
    (\h t -> (reverse t) ++ (h : Nil));

map f l = l Nil (\h t -> f h : map f t);

foldr f acc l = l acc (\h t -> f h (foldr f acc t));

head l = l undefined (\h _ -> h);
tail l = l undefined (\_ t -> t);
cmp_list l l' =
  l
    (l'
      True
      (\_ _ -> False))
    (\h t ->
      l'
	False
	(\h' t' ->
	  (h == h')
	    (cmp_list t t')
	    False));

last l = l undefined (\h t -> t h (\_ _ -> last t));

inc n = n + '!' - ' ';
find_list a l =
  l
    undefined
    (\h t ->
      (cmp_list (fst h) a)
	(' ' - ' ')
	(inc (find_list a t)));

combinators = "SICKBEL+-:";

is_comb v l = l False (\h t -> (cmp_list v [h]) True (is_comb v t));

pure x inp = Just (x, inp);
fail = const Nothing;
bind f m = m Nothing (\x -> x f);
(<*>) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q t)) (p inp);
(<*>|) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q I t)) (p inp);
(<|>) p q = \inp -> (p inp) (q inp) Just;
(<$>) f p = pure f <*> p;
(<$) f p = const <$> pure f <*> p;
(<*) p q = const <$> p      <*> q;
(*>) p q = id    <$  p      <*> q;

opt def x = x <|> pure def;
many p = opt Nil ((:) <$> p <*>| (\_ -> many p));
many1 p = (:) <$> p <*> many p;
appall x l = l x (\h t -> appall (h x) t);
chainl1 op p = appall <$> p <*> many (flip <$> op <*> p);
choice = foldr (<|>) fail;

sepBy1 sep p = (:) <$> p <*> many (sep *> p);
sepBy sep p  = opt Nil (sepBy1 sep p);

range l r = sat (\x -> (l <= x) && (x <= r));
lower = range 'a' 'z';
upper = range 'A' 'Z';
letter = lower <|> upper;
ide = letter <|> char ''' <|> char '_';
digit = range '0' '9';

-- data Expr = Com [Char] | Var [Char] | App Expr Expr | Lam [Char] Expr
Com c   = \a _ _ _ -> a c;
Var v   = \_ b _ _ -> b v;
App l r = \_ _ c _ -> c l r;
Lam v b = \_ _ _ d -> d v b;

(@) = App;

-- data Deb = Zero | Succ Deb | Pass Expr | Abs Deb | (#) Deb Deb
Zero    = \a _ _ _ _ -> a;
Succ n  = \_ b _ _ _ -> b n;
Pass e  = \_ _ c _ _ -> c e;
Abs e   = \_ _ _ d _ -> d e;
(#) l r = \_ _ _ _ e -> e l r;

deb e v n =
  e
    (const (Pass e))
    (\v' -> (cmp_list v v') n e)
    (\l r -> (deb l v n) # (deb r v n))
    (\v' b -> Abs (deb (deb b v' Zero) v (Succ n)));

Closed e = \a _ _ _ -> a e;
Need e   = \_ b _ _ -> b e;
Weak e   = \_ _ c _ -> c e;
Variable = \_ _ _ d -> d;

babsClosed d r =
  r
    (\d' -> Closed (d @ d'))
    (\e  -> Need (Closed (Com "B" @ d) $$ e))
    (\e  -> Weak (Closed d $$ e))
    (Need (Closed d))
  ;

babsNeed e r =
  r
    (\d  -> Need ((Closed (Com "C" @ Com "C" @ d)) $$ e))
    (\e' -> Need (Closed (Com "S") $$ e $$ e'))
    (\e' -> Need (Closed (Com "C") $$ e $$ e'))
    (Closed (Com "S") $$ e $$ Closed (Com "I"))
  ;

babsWeak e r =
  r
    (\d  -> Weak (e $$ r))
    (\e' -> Need (Closed (Com "B") $$ e $$ e'))
    (\e' -> Weak (e $$ e'))
    (Need e)
  ;

babsVariable r =
  r
    (\d -> Need (Closed (Com "C" @ Com "I" @ d)))
    (\e -> Need (Closed (Com "S" @ Com "I") @ e))
    (\e -> Need (Closed (Com "C" @ Com "I") $$ e))
    undefined
  ;

babsa l r =
  l
    (flip babsClosed r)
    (flip babsNeed r)
    (flip babsWeak r)
    (babsVariable r);

($$) = babsa;

nbabs e =
  e
    (Need (Closed (Com "I")))
    (Weak . nbabs)
    Closed
    (\e -> (nbabs e)
      (\d -> Closed ((Com "K") @ d))
      id
      (babsa (Closed (Com "K")))
      (Com "I"))
    (\l r -> babsa (babs l) (babs r));

sat f inp = inp Nothing (\h t -> f h (pure h t) Nothing);

char c = sat ((==) c);
any = sat (\_ -> const);

space = char ' ';
newline = char '
';
tab = char '	';

nul = space
  <|> (tab
  <|> (newline
  <|> (char '-'
   <*  (char '-'
    *> many (sat (\x -> (x == '
') False True))))));

blank p = many nul
       *> p
      <*  many nul;

operators = ":=|+-,.&<*>$@#!";

op = char ':' <|>
    (char '=' <|>
    (char '|' <|>
    (char '+' <|>
    (char '-' <|>
    (char ',' <|>
    (char '.' <|>
    (char '&' <|>
    (char '<' <|>
    (char '*' <|>
    (char '>' <|>
    (char '$' <|>
    (char '@' <|>
    (char '#'))))))))))))); -- choice (map char operators);
opp = many op;

parentP = char '(' *> blank expr <* char ')';

name = (:) <$> ide <*> many (ide <|> digit);

lambdaP = (char '\'
       *> ((flip wrap_lam . reverse)
      <$> many (blank name)
      <*> (char '-'
       *> (char '>'
       *> (many nul
       *> expr)))));

chr c = Com ('#' : (c : Nil));

charP = char '''
     *> ((chr <$> any)
    <*  char ''');

str l = l
	  (Var "K")
	  (\h t -> Var ":" @ chr h @ str t);

dquote = '"'; --"

stringP = char dquote
       *> ((str <$> many (sat (\x -> (x == dquote) False True)))
      <*  char dquote);

lst l = l
	 (Var "K")
	 (\h t -> Var ":" @ h @ lst t);

listP = lst
    <$> (char '['
     *> (sepBy (blank (char ';')) expr
    <*  char ']'));

varP  = (\v -> is_comb v combinators (Com v) (Var v)) <$> name;
opP   = char '(' *> (Var <$> blank opp <* char ')');
atomP = parentP
    <|> (charP
    <|> (varP
    <|> (lambdaP
    <|> (stringP
    <|> (listP
    <|> opP)))));
appP  = chainl1 (blank (pure App)) atomP;
expr  = chainl1 ((\x y z -> Var x @ y @ z) <$> blank opp) appP;

wrap_lam e l =
  l
    e
    (\h t ->
      wrap_lam (Lam h e) t);

equal = (flip wrap_lam . reverse)
    <$> many (blank name)
    <*  blank (char '=')
    <*> expr;

top_level = (,)
	<$> (name <|> (char '(' *> blank opp <* char ')'))
	<*> blank equal
	<*  char ';';

show e =
  e
    id
    id
    (\l r -> '`' : show l ++ show r)
    (\v b -> '\': (v ++ ('.' : show b)));

app e f def = e (const def) (const def) f (\_ _ -> def);

com e v f def =
  e
    (\v' -> (cmp_list (v : Nil) v') f def)
    (const def)
    (\_ _ -> def)
    (\_ _ -> def);

bopt p q = Com "B" @ p @ q;
kopt s p q l r = com
		   l
		   'K'
		   (Com "K" @ (q @ r))
		   (bopt q s);

copt e s p =
  app
    s
    (\l q ->
      com
	l
	'K'
	(Com "C" @ p @ q)
	e)
    e;

svopt e s p l q = com
		    l
		    'K'
		    (s
		       (\v -> (cmp_list "I" v) q (bopt q s))
		       (const (bopt q s))
		       (kopt s p q)
		       (\_ _ -> bopt q s))
		    e;

optimize e =
  app
    e
    (\l s ->
      app
	l
	(\l' p ->
	  com
	    l'
	    'S'
	    (app
	      p
	      (svopt e s p)
	      (copt e s p))
	    e)
	e)
    e;

abs v e =
  e
    (\_ -> Com "K" @ e)
    (\v' -> (cmp_list v' v)
	    (Com "I")
	    (Com "K" @ e))
    (\l r -> optimize (Com "S" @ abs v l @ abs v r))
    undefined;


babs e =
  e
    Com
    Var
    (\l r -> (babs l) @ (babs r))
    (\v b -> abs v (babs b));

subst e l = e
	       Com
	       (\v ->
		  (Com ('@' : ((' ' + find_list v l) : Nil))))
	       (\p q -> subst p l @ subst q l)
	       (\v b -> Lam v (subst b l));

smap f l = l Nil (\h t -> (fst h, f (snd h)) : smap f t);

main = (foldr (\l l' -> l ++ (';' : l')) Nil .
	map (show . snd) .
	(\l -> smap (flip subst l . babs) l) .
	fst .
	get .
	many (blank top_level));
