undefined = I;

-- Types
(,) x y     = \f -> f x y;
curry f l r = f (l, r);
uncurry f x = x f;
fst x = x const;
snd x = x (\_ s -> s);

Nothing = K;
Just x  = \_ g -> g x;

Nil     = K;
(:) h t = \_ g -> g h t;

-- Combinators
id x = x;
const x _ = x;
fix x = x (fix x);
flip f x y = f y x;

(&) x f = f x;
($) f x = f x;
(||) f g x y = f x (g x y);

-- Lists
(++) l l' = l l' (\h t -> h : (t ++ l'));
ifNil l t f = l t (\_ _ -> f);
head l = l undefined (\h _ -> h);
tail l = l undefined (\_ t -> t);

-- Parser for combinators
closes h = (hd == ')') || (hd == ';');
pre h = (hd == '#') || (hd == '@');
add r acc p = r (ifNil acc p ('`' : (acc ++ p)));

sub r acc t = uncurry (add r acc) (r Nil t);

atom r acc h t = ((\x y -> add r acc h:x y) (pre h (((head t) : Nil), (tail t)) (Nil, t)));

term acc s =
    s undefined (\h t -> (closes h) (acc, t) ((h == '(') (sub term acc t) (atom term acc h t)));

-- Parser combinator library
pure x inp = Just (x, inp);
bind f m = m Nothing (\x -> x f);

-- case x inp of
--   Nothing      -> Nothing
--   Just (a, l)  ->
--     case y l of
--       Nothing -> Nothing
--       Just (b, l') -> Just (a b, l')
(<*>) x y = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (y t)) (x inp);

-- case x inp of
--   Nothing -> y inp
--   Just n  -> Just n
(<|>) x y = \inp -> (x inp) (y inp) Just;

(<$>) f p = pure f <*> p;

(<$) f p = const <$> pure <*> p;
(<*) p q = const <$> p <*> q;
(*>) p q = id <$ p <*> q;

-- Ast
-- data Expr = Com [Char] | Var Char | App Expr Expr | Lam Char Expr
Com c   = \a _ _ _ -> a c;
Var v   = \_ b _ _ -> b v;
App l r = \_ _ c _ -> c l r;
Lam v b = \_ _ _ d -> d v b;

(:@) = App;

-- Parser
-- Parses a character satisfying the predicate f.
-- case inp of
--   [] -> Nothing
--   h : tl -> if f h then (pure h t) else Nothing
sat f inp = inp Nothing (\h t -> f h (pure h t) Nothing);

-- Matches the character c.
char c = sat ((==) c);
-- Matches any character.
any = sat (\_ -> const);

char_v = sat (\c -> flip ((c == ';') || (c == ')')));
pre = Com <$> ((:) <$> (char '#' <|> char '@')) <*> ((\c -> c : Nil) <$> any);

parent r = char '(' *> r <* char ')';
lambda r = char '\' *> (Lam <$> var) <*> (char '.' *> r);
var = Var <$> char_v;
atom r = pre <|> var <|> lambda r <|> parent r;
app r = App <$> atom r <*> atom r;

show e =
  e id (\x -> x : Nil) (\l r -> (show l) ++ (' ' : show r)) (\v b -> '\': (v : ('.' : show b)));

main = show (Lam 'a' (Com ('#' : ('a' : Nil))) :@ Com ('a':Nil));
-- Bracket abstraction
