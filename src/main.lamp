undefined = I;
id = I;
const = K;
flip = C;
(.) = B;

True  = \x _ -> x;
False = \_ y -> y;

(||) f g x y = f x (g x y);
(&&) f g x y = f (g x y) y;

(==) = E;
(<=) = L;

(,) x y     = \f -> f x y;
fst x = x const;
snd x = x (\_ s -> s);

Nothing = K;
Just x  = \_ g -> g x;
get e = e undefined id;

Nil = K;

(++) l l' =
  l
    l'
    (\h t -> h : (t ++ l'));

reverse l =
  l
    Nil
    (\h t -> (reverse t) ++ (h : Nil));

map f l = l Nil (\h t -> f h : map f t);

foldr f acc l = l acc (\h t -> f h (foldr f acc t));
foldl f acc l = l acc (\h t -> foldl f (f acc h) t);

head l = l undefined (\h _ -> h);
tail l = l undefined (\_ t -> t);
cmp_list l l' =
  l
    (l'
      True
      (\_ _ -> False))
    (\h t ->
      l'
	False
	(\h' t' ->
	  (h == h')
	    (cmp_list t t')
	    False));

last l = l undefined (\h t -> t h (\_ _ -> last t));

find_list a l =
  l
    undefined
    (\h t ->
      (cmp_list (fst h) a)
        0
	(find_list a t + 1));

int_of_string = foldl (\a b -> a * 10 + b - '0') 0;

-- Parser ----------------------------------------------------------------------

combinators = "SICKBEL+-:*";

is_comb v l = l False (\h t -> (cmp_list v [h]) True (is_comb v t));

pure x inp = Just (x, inp);
fail = const Nothing;
bind f m = m Nothing (\x -> x f);
(<*>) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q t)) (p inp);
(<*>|) p q = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (q I t)) (p inp);
(<|>) p q = \inp -> (p inp) (q inp) Just;
(<$>) f p = pure f <*> p;
(<$) f p = const <$> pure f <*> p;
(<*) p q = const <$> p      <*> q;
(*>) p q = id    <$  p      <*> q;

opt def x = x <|> pure def;
many p = opt Nil ((:) <$> p <*>| (\_ -> many p));
many1 p = (:) <$> p <*> many p;
appall x l = l x (\h t -> appall (h x) t);
chainl1 op p = appall <$> p <*> many (flip <$> op <*> p);
choice = foldr (<|>) fail;

sepBy1 sep p = (:) <$> p <*> many (sep *> p);
sepBy sep p  = opt Nil (sepBy1 sep p);

range l r = sat (\x -> (l <= x) && (x <= r));
lower = range 'a' 'z';
upper = range 'A' 'Z';
letter = lower <|> upper;
ide = letter <|> char ''' <|> char '_';
digit = range '0' '9';

-- data Expr = Com [Char] | Var [Char] | App Expr Expr | Lam [Char] Expr
Com c   = \a _ _ _ -> a c;
Var v   = \_ b _ _ -> b v;
App l r = \_ _ c _ -> c l r;
Lam v b = \_ _ _ d -> d v b;

sat f inp = inp Nothing (\h t -> f h (pure h t) Nothing);

char c = sat ((==) c);
any = sat (\_ -> const);

space = char ' ';
newline = char '
';
tab = char '	';

nul = space
  <|> (tab
  <|> (newline
  <|> (char '-'
   <*  (char '-'
    *> many (sat (\x -> (x == '
') False True))))));

blank p = many nul
       *> p
      <*  many nul;

operators = ":=|+-,.&<*>$@#!";

op = char ':' <|>
    (char '=' <|>
    (char '|' <|>
    (char '+' <|>
    (char '-' <|>
    (char ',' <|>
    (char '.' <|>
    (char '&' <|>
    (char '<' <|>
    (char '*' <|>
    (char '>' <|>
    (char '$' <|>
    (char '@' <|>
    (char '#'))))))))))))); -- choice (map char operators);
opp = many op;

parentP = char '(' *> blank expr <* char ')';

name = (:) <$> ide <*> many (ide <|> digit);

lambdaP = (char '\'
       *> ((flip wrap_lam . reverse)
      <$> many (blank name)
      <*> (char '-'
       *> (char '>'
       *> (many nul
       *> expr)))));

chr c = Com ('#' : (c : Nil));

charP = char '''
     *> ((chr <$> any)
    <*  char ''');

str l = l
	  (Com "K")
	  (\h t -> Com ":" @ chr h @ str t);

dquote = '"'; --"

stringP = char dquote
       *> ((str <$> many (sat (\x -> (x == dquote) False True)))
      <*  char dquote);

lst l = l
	 (Com "K")
	 (\h t -> Com ":" @ h @ lst t);

listP = lst
    <$> (char '['
     *> (sepBy (blank (char ';')) expr
    <*  char ']'));

numberP = ((\x -> Com ['#'; x]) . int_of_string)
      <$> many1 digit;

varP  = (\v -> is_comb v combinators (Com v) (Var v))
    <$> (name
    <|> (char '(' *> blank opp <* char ')'));

atomP = parentP
    <|> (charP
    <|> (varP
    <|> (lambdaP
    <|> (stringP
    <|> (listP
    <|> (numberP))))));

appP  = chainl1 (blank (pure App)) atomP;

expr  = chainl1 ((\x y z ->
                  (is_comb x combinators (Com x) (Var x)) @ y @ z)
		<$> blank opp) appP;

wrap_lam e l =
  l
    e
    (\h t ->
      wrap_lam (Lam h e) t);

equal = (flip wrap_lam . reverse)
    <$> many (blank name)
    <*  blank (char '=')
    <*> expr;

top_level = (\f s -> [f, s])
	<$> (name <|> (char '(' *> blank opp <* char ')'))
	<*> blank equal
	<*  char ';';

--------------------------------------------------------------------------------

-- Bracket abstraction ---------------------------------------------------------

-- data Deb = Zero | Succ Deb | Pass Expr | Abs Deb | (#) Deb Deb
Zero    = \a _ _ _ _ -> a;
Succ n  = \_ b _ _ _ -> b n;
Pass e  = \_ _ c _ _ -> c e;
Abs e   = \_ _ _ d _ -> d e;
($#) l r = \_ _ _ _ e -> e l r;

find l v def acc = l def (\h t -> (cmp_list h v) acc (find t v def (Succ acc)));

deb e env =
  e
    (const (Pass e))
    (\v -> find env v (Pass e) Zero)
    (\l r -> deb l env $# deb r env)
    (\v b -> Abs (deb b (v : env)))
  ;

Closed e = \a _ _ _ -> a e;
Need e   = \_ b _ _ -> b e;
Weak e   = \_ _ c _ -> c e;
Variable = \_ _ _ d -> d;

babsClosed d r =
  r
    (\d' -> Closed (d @ d'))
    (\e  -> Need (Closed (Com "B" @ d) $$ e))
    (\e  -> Weak (Closed d $$ e))
    (Need (Closed d))
  ;

babsNeed e r =
  r
    (\d  -> Need ((Closed (Com "C" @ Com "C" @ d)) $$ e))
    (\e' -> Need (Closed (Com "S") $$ e $$ e'))
    (\e' -> Need (Closed (Com "C") $$ e $$ e'))
    (Need (Closed (Com "S") $$ e $$ Closed (Com "I")))
  ;

babsWeak e r =
  r
    (\d  -> Weak (e $$ Closed d))
    (\e' -> Need (Closed (Com "B") $$ e $$ e'))
    (\e' -> Weak (e $$ e'))
    (Need e)
  ;

babsVariable r =
  r
    (\d -> Need (Closed (Com "C" @ Com "I" @ d)))
    (\e -> Need (Closed (Com "S" @ Com "I") $$ e))
    (\e -> Need (Closed (Com "C" @ Com "I") $$ e))
    (Need (Closed (Com "S" @ Com "I" @ Com "I")))
  ;

babsa l r =
  l
    (flip babsClosed r)
    (flip babsNeed r)
    (flip babsWeak r)
    (babsVariable r)
  ;

($$) = babsa;

babs e =
  e
    Variable
    (Weak . babs)
    Closed
    (\e -> (babs e)
      (\d -> Closed (Com "K" @ d))
      id
      (babsa (Closed (Com "K")))
      (Closed (Com "I")))
    (\l r -> (babs l) $$ (babs r));

--------------------------------------------------------------------------------

subst e l = e
	       Com
	       (\v ->
		  (Com ('@' : ((32 + find_list v l) : Nil))))
	       (\p q -> subst p l @ subst q l)
	       (\v b -> Lam v (subst b l));

smap f l = l Nil (\h t -> (fst h, f (snd h)) : smap f t);

show e =
  e
    id
    id
    (\l r -> '`' : show l ++ show r)
    (\v b -> '\': (v ++ ('.' : show b)));

(@) = App;

main = (foldr (\l l' -> l ++ (';' : l')) [] .
	map (show . snd) .
	(\l -> smap (flip subst l .
	            (\x -> x I undefined undefined undefined) .
                    babs . (\x -> deb x [])) l) .
	foldr (++) [] .
	fst .
	get .
	many (blank top_level));
