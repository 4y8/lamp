-- Types
(,) x y = \f -> f x y;
curry f l r = f (l, r);
uncurry f x = x f;

Nothing x _ = x;
Just x f g  = g x;

Nil       = \f _ -> f;
(:) hd tl = \_ g -> g hd tl;

-- Combinators
id x = x;
const x _ = x;
fix x = x (fix x);
flip f x y = f y x;

(&) x f = f x;
($) f x = f x;
(||) f g x y = f x (g x y);

-- Lists
(++) l l' = l l' (\hd tl -> hd : (tl ++ l'));
ifNil l t f = l t (\_ _ -> f);
head l = l undefined (\hd _ -> hd);
tail l = l undefined (\_ tl -> tl);

-- Parser

closes h = (hd == ')') || (hd == ';');
pre h = (hd == '#') || (hd == '@');
add r acc p = r (ifNil acc p ('`' : (acc ++ p)));

sub r acc t = uncurry (add r acc) (r Nil t);

atom r acc h t = ((\x y -> add r acc h:x y) (pre h (((head t) : Nil), (tail t)) (Nil, t)));

term acc s =
    s undefined (\h t -> (closes h) (acc, t) ((h == '(') (sub term acc t) (atom term acc h t)));

-- Parser Combinators
pure x inp = Just (x, inp);
bind f m = m Nothing (\x -> x f);
(<*>) x y = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (y t)) (x inp);
(<|>) x y = \inp -> (x inp) (y inp) Just;
(<$>) f x = pure f <*> x;
(*>) p q = (\_ x -> x) <$> p <*> q;
(<*) p q = (\x _ -> x) <$> p <*> q;

-- Bracket abstraction