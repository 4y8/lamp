-- Types
(,) x y = \f -> f x y;
curry f l r = f (l, r);
uncurry f x = x f;

Nothing x _ = x;
Just x f g  = g x;

Nil       = \f _ -> f;
(:) hd tl = \_ g -> g hd tl;

-- Combinators
id x = x;
const x _ = x;
fix x = x (fix x);
flip f x y = f y x;

(&) x f = f x;
($) f x = f x;
(||) f g x y = f x (g x y);

-- Lists
(++) l l' = l l' (\hd tl -> hd : (tl ++ l'));
ifNil l t f = l t (\_ _ -> f);
head l = l undefined (\hd _ -> hd);
tail l = l undefined (\_ tl -> tl);

-- Parser for combinators
closes h = (hd == ')') || (hd == ';');
pre h = (hd == '#') || (hd == '@');
add r acc p = r (ifNil acc p ('`' : (acc ++ p)));

sub r acc t = uncurry (add r acc) (r Nil t);

atom r acc h t = ((\x y -> add r acc h:x y) (pre h (((head t) : Nil), (tail t)) (Nil, t)));

term acc s =
    s undefined (\h t -> (closes h) (acc, t) ((h == '(') (sub term acc t) (atom term acc h t)));

-- Parser combinator library
pure x inp = Just (x, inp);
bind f m = m Nothing (\x -> x f);

-- case x inp of
--   Nothing      -> Nothing
--   Just (a, l)  ->
--     case y l of
--       Nothing -> Nothing
--       Just (b, l') -> Just (a b, l')
(<*>) x y = \inp -> bind (\a t -> bind (\b u -> pure (a b) u) (y t)) (x inp);

-- case x inp of
--   Nothing -> y inp
--   Just n  -> Just n
(<|>) x y = \inp -> (x inp) (y inp) Just;

(<$>) f p = pure f <*> p;

(<$) f p = const <$> pure <*> p;
(<*) p q = const <$> p <*> q;
(*>) p q = id <$ p <*> q;

-- Ast
-- data Expr = Com [Char] | Var Char | App Expr Expr | Abs Char Ast
R s   = \a b c d -> a s;
V v   = \a b c d -> b v;
A x y = \a b c d -> c x y;
L x y = \a b c d -> d x y;

-- Parser
-- Parses a character satisfying the predicate f.
-- case inp of
--   [] -> Nothing
--   h : tl -> if f h then (pure h t) else Nothing 
sat f inp = inp Nothing (\h t -> f h (pure h t) Nothing);

-- Matches the character c.
char c = sat ((==) c);
-- Matches any character. 
any = sat (\_ -> const);

pre = (:) <$> (char '#' <|> char '@') <*> (flip (:) const <$> any);

-- Bracket abstraction
